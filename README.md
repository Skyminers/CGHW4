# 计算机图形学作业四

> zju cg

## 绘制简单太阳系

绘制了一颗太阳、两颗行星以及一颗卫星   

太阳的颜色使用纯黄色， 其他行星、卫星的颜色为花色。

/截屏2020-10-26 上午1.58.27.png

> 由于我使用的是glfw+glm库，所以助教可能没有办法进行编译，所以我在这里提供了exe可执行文件以及Unix可执行文件

## 摄像机支持

可以通过键盘输入 W、A、S、D 来控制摄像机向前、向左、向后、向右移动。 额外地，与MC类似，可以通过空格键(space)向上移动、通过左(Shift)向下移动。

但是由于这里没有绝对的上，所以向上向下移动定义为与垂直摄像机方向向量以及摄像机右向量平行的向量。

## 球形绘制

通过绘制若干三角形（5000个）来构建球体的表面，首先使用若干点（2500个）来覆盖整个球面。

对于绘制点坐标的计算：将球分为xOz圆周以及在y方向上的高度，将圆周角、高度角划分为50等份，依次计算每个点的点坐标。

之后构建索引，对于圆周上的每个点，通过构建两个三角形的方式来绘制平行四边形。依此来覆盖整个平面。

对于颜色的选择，处于片段 `(x,y)` 的节点（x为圆周划分片段编号，y为纵轴划分片段编号）颜色设置为`(10*x, 10*y, 10*(x+y))%255/255` 

## 着色器设置

着色器设置为接受顶点坐标以及颜色坐标，进行节点绘制时需要使用6个`float`来指定点坐标以及颜色RGB

同时着色器接受一个`bool`变量来表示当前绘制的是否是太阳，如果传入的`bool`变量为`true`，则着色器不接受颜色标识并且使用黄色来进行绘制。

## 行星运动实现

行星经过如下矩阵变换（行星初始位置为在原点）：

1. 左乘旋转矩阵（自转），绕一个随机指定的轴进行旋转（因为具体是哪个轴是无所谓的）
2. 左乘平移矩阵（移动到公转轨道），为每个行星设置一个初始向量，移动到向量的终点位置，作为公转的起点。
3. 左乘旋转矩阵（公转），首先计算该旋转矩阵的旋转轴，我们只需要保证这个旋转轴与位置向量垂直即可，所以可以通过计算位置向量与`(0,0,1)`向量的叉积，就可以求出公转轴。

卫星经过如下矩阵变换（卫星的初始位置也在原点）:

1. 左乘旋转矩阵（自转），与行星相似，绕一个随机指定轴旋转
2. 左乘平移矩阵（移动到公转轨道），与行星相似，移动到一个为卫星设置的初始位置向量的位置
3. 左乘旋转矩阵（公转）， 与行星相似，计算旋转轴构建旋转矩阵进行旋转
4. 左乘平移矩阵（移动到行星公转位置），找到该卫星需要围绕的那颗行星的位置向量，通过该位置向量来构建平移矩阵。
5. 左乘旋转矩阵（随卫星公转）， 左乘该行星围绕的行星的旋转矩阵，来实现随行星运动
6. 左乘缩放矩阵（使卫星小一点）， 左乘一个指定的缩放矩阵，缩小卫星的大小

对于持续旋转的记录，我保持了旋转矩阵来表示当前行星旋转的情况，然后每一次渲染时通过`deltaTime`来计算这段时间旋转的角度，然后使用该角度构建旋转矩阵乘到累积的表示当前行星旋转情况的旋转矩阵中。

对于自转矩阵，为了实现方便，所有行星公用同一个自转轴与自转矩阵。

## 代码文件

- main.cpp : 主函数部分，包括初始化以及渲染部分、通过矩阵计算行星位置部分
- Sphere.h/Sphere.cpp : 球形绘制类，该部分绘制一个球，并且将节点信息以及索引信息储存在`vector`当中并且返回首地址。
- Camera.h/Camera.cpp : 摄像机类，为了使main.cpp文件尽可能简洁，其中关于摄像机方向设置以及移动都在摄像机类中实现。
- Shaders.h/Shaders.cpp : 着色器类，该类封装了对于着色器的读取、编译、链接以及对于着色器变量的捕获修改。
- vertexShader.glsl : 顶点着色器
- fragmentShader.glsl : 片段着色器

## 其他说明

使用 Clion 完成项目，使用库： `glfw 3.3`, `glm 0.9.8.5`
